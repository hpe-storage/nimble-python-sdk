#
#   Â© Copyright 2020 Hewlett Packard Enterprise Development LP
#

import logging
import uuid
import requests

from requests.packages.urllib3.exceptions import InsecureRequestWarning
from .exceptions import NimOSAuthenticationError, NimOSAPIError

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

class SessionManager:
    """Tracks current NimOS REST sessions in order to reuse them"""

    _SESSIONS = {}

class NimOSAPIClient:
    """NimOS REST API Client session"""

    _ENDPOINTS = {
        # This endpoint list was auto-generated by the Python SDK generator; DO NOT EDIT.
        'versions' : 'versions',
        'application_categories' : 'v1/application_categories',
        'chap_users' : 'v1/chap_users',
        'master_key' : 'v1/master_key',
        'alarms' : 'v1/alarms',
        'volumes' : 'v1/volumes',
        'shelves' : 'v1/shelves',
        'key_managers' : 'v1/key_managers',
        'protection_templates' : 'v1/protection_templates',
        'folders' : 'v1/folders',
        'tokens' : 'v1/tokens',
        'fibre_channel_interfaces' : 'v1/fibre_channel_interfaces',
        'network_interfaces' : 'v1/network_interfaces',
        'arrays' : 'v1/arrays',
        'fibre_channel_configs' : 'v1/fibre_channel_configs',
        'initiators' : 'v1/initiators',
        'performance_policies' : 'v1/performance_policies',
        'space_domains' : 'v1/space_domains',
        'snapshot_collections' : 'v1/snapshot_collections',
        'replication_partners' : 'v1/replication_partners',
        'events' : 'v1/events',
        'snapshots' : 'v1/snapshots',
        'application_servers' : 'v1/application_servers',
        'user_policies' : 'v1/user_policies',
        'user_groups' : 'v1/user_groups',
        'subnets' : 'v1/subnets',
        'controllers' : 'v1/controllers',
        'fibre_channel_sessions' : 'v1/fibre_channel_sessions',
        'users' : 'v1/users',
        'protection_schedules' : 'v1/protection_schedules',
        'initiator_groups' : 'v1/initiator_groups',
        'access_control_records' : 'v1/access_control_records',
        'active_directory_memberships' : 'v1/active_directory_memberships',
        'fibre_channel_ports' : 'v1/fibre_channel_ports',
        'protocol_endpoints' : 'v1/protocol_endpoints',
        'witnesses' : 'v1/witnesses',
        'jobs' : 'v1/jobs',
        'audit_log' : 'v1/audit_log',
        'pools' : 'v1/pools',
        'volume_collections' : 'v1/volume_collections',
        'disks' : 'v1/disks',
        'fibre_channel_initiator_aliases' : 'v1/fibre_channel_initiator_aliases',
        'groups' : 'v1/groups',
        'software_versions' : 'v1/software_versions',
        'network_configs' : 'v1/network_configs',
    }

    def __init__(self, hostname, username, password, port=5392):
        """Initialize a session to the NimOS REST API"""

        connection_hash = str(uuid.uuid3(uuid.NAMESPACE_OID, f'{hostname}{port}{username}{password}'))

        self.hostname = hostname
        self.port = port

        self.__auth = {
            'data': {
                'username': username,
                'password': password,
                'app_name': 'NimOS REST Client'
            }
        }

        self.__connection_hash = connection_hash

        if connection_hash in SessionManager._SESSIONS:
            self.session_id, self.session_token = SessionManager._SESSIONS[connection_hash]
            self.connected = True
            self._headers = {'X-Auth-Token': str(self.session_token)}

        else:
            self._headers = {}
            self.session_token = None
            self.session_id = None
            self.connected = self._connect()

    def _connect(self):
        """Perform NimOS authentication and session token retrieval"""

        try:
            response = requests.post(
                f"https://{self.hostname}:{self.port}/{self._ENDPOINTS['tokens']}",
                json=self.__auth,
                verify=False
            )

            sessiondata = response.json()

            if 'messages' in sessiondata and sessiondata['messages'][0]['code'] == 'SM_http_unauthorized':
                logging.debug(sessiondata)
                raise NimOSAuthenticationError("Invalid credentials")

            sessiondata = sessiondata['data']

            if 'session_token' not in sessiondata:
                logging.debug(sessiondata)
                raise NimOSAuthenticationError("Invalid credentials")

            self.session_token = sessiondata['session_token']
            self.session_id = sessiondata['id']
            self._headers = {'X-Auth-Token': str(self.session_token)}

            SessionManager._SESSIONS[self.__connection_hash] = (self.session_id, self.session_token)

            return True

        except requests.ConnectionError as error:
            logging.exception(error)
            raise ConnectionError(f"Error connecting to {self.hostname}")

    def _refresh_connection(self):
        """Checks status of NimOS session and reconnects if necessary"""

        try:
            response = requests.get(
                f"https://{self.hostname}:{self.port}/{self._ENDPOINTS['tokens']}/{self.session_id}",
                headers=self._headers,
                verify=False
            ).json()

            if 'messages' in response and response['messages'][0]['severity'] == 'error':
                self._connect()

        except requests.ConnectionError as error:
            logging.exception(error)
            raise ConnectionError(f"Error reconnecting to {self.hostname}")

    def close_connection(self):
        """Closes NimOS session (deletes user token)"""

        try:
            requests.delete(
                f"https://{self.hostname}:{self.port}/{self._ENDPOINTS['tokens']}/{self.session_id}",
                headers=self._headers,
                verify=False
            )

            del SessionManager._SESSIONS[self.__connection_hash]

        except requests.exceptions.RequestException as error:
            logging.exception(error)
            raise ConnectionError("Error closing connection")

    def get(self, endpoint, **params):
        """Wrapper for GET requests"""

        url=f'https://{self.hostname}:{self.port}/{endpoint}'
        try:
            while 1:
                response = requests.get(
                    url,
                    params=params,
                    headers=self._headers,
                    verify=False
                )

                if response.status_code >= 400:
                    if 'SM_http_unauthorized' in str(response.content):
                        self._refresh_connection()
                    else:
                        print("URL: ", url)
                        raise NimOSAPIError(response.json())
                else:
                    break

            # Check for errors if any in the response (Treat partial response as an error)
            if 'messages' in response.json():
                raise NimOSAPIError(response.json()['messages'])

            # Retrieves as per 'rest_api_row_limit' configuration on array
            if 'pageSize' in params:
                return response.json()

            if 'totalRows' not in response.json():
                return response.json()

            # If startRow and/or endRow is specified, then retrieve records accordingly.
            # If unspecified, then retrieves all the available records.
            paginated_data = list()
            paginated_data.extend(response.json()["data"])
            total_rows = response.json()['totalRows']
            retrieved_rows = len(paginated_data)
            #current_end_row = response.json()['endRow']

            if 'startRow' in params and 'endRow' in params:
                requested_rows = params['endRow'] - params['startRow']
            elif 'startRow' not in params and 'endRow' not in params:
                requested_rows = total_rows # Get all available records
            else:
                if 'startRow' in params:
                    requested_rows = total_rows - params['startRow']
                else:
                    requested_rows = params['endRow']
            #print("Total records requested:", requested_rows, ", Retrieved records:", retrieved_rows)

            pending_rows = requested_rows-retrieved_rows
            params.clear()
            while pending_rows > 0:
                params['startRow'] = response.json()['endRow']
                #print("Retrieved:", retrieved_rows, "Pending:", pending_rows, "Next startRow:", params['startRow'])
                response = requests.get(
                    url,
                    params=params,
                    headers=self._headers,
                    verify=False,
                )
                records = response.json()["data"][:pending_rows]
                records_count = len(records)
                paginated_data.extend(records)
                pending_rows -= records_count
                retrieved_rows += records_count
                # TODO: Handle change in the total no. of rows during this large operation

            return paginated_data

        except requests.exceptions.RequestException as error:
            logging.exception(error)
            raise ConnectionError(f"Error communicating with {self.hostname}")

    def delete(self, endpoint):
        """Wrapper for DELETE requests"""

        try:
            while 1:
                response = requests.delete(
                    f'https://{self.hostname}:{self.port}/{endpoint}',
                    headers=self._headers,
                    verify=False
                )

                if response.status_code >= 400:
                    if 'SM_http_unauthorized' in str(response.content):
                        self._refresh_connection()
                    else:
                        raise NimOSAPIError(response.json())
                else:
                    break

            return response.json()

        except requests.exceptions.RequestException as error:
            logging.exception(error)
            raise ConnectionError(f"Error communicating with {self.hostname}")

    def put(self, endpoint, **payload):
        """Wrapper for PUT requests"""

        try:
            while 1:
                response = requests.put(
                    f'https://{self.hostname}:{self.port}/{endpoint}',
                    headers=self._headers,
                    json={'data': payload},
                    verify=False
                )

                if response.status_code >= 400:
                    if 'SM_http_unauthorized' in str(response.content):
                        self._refresh_connection()
                    else:
                        raise NimOSAPIError(response.json())
                else:
                    break

            return response.json()

        except requests.exceptions.RequestException as error:
            logging.exception(error)
            raise ConnectionError(f"Error communicating with {self.hostname}")

    def post(self, endpoint, **payload):
        """Wrapper for POST requests"""

        try:
            while 1:
                response = requests.post(
                    f'https://{self.hostname}:{self.port}/{endpoint}',
                    headers=self._headers,
                    json={'data': payload},
                    verify=False
                )

                if response.status_code >= 400:
                    if 'SM_http_unauthorized' in str(response.content):
                        self._refresh_connection()
                    else:
                        raise NimOSAPIError(response.json())
                else:
                    break

            return response.json()

        except requests.exceptions.RequestException as error:
            logging.exception(error)
            raise ConnectionError(f"Error communicating with {self.hostname}")

    def get_resource(self, resource, ident, **params):
        if resource not in self._ENDPOINTS:
            raise ValueError(f"Unknown resource {resource}")

        resp = self.get(f"{self._ENDPOINTS[resource]}/{ident}", **params)
        return resp['data'] if 'data' in resp else resp

    def list_resources(self, resource, detail=False, **params):
        if resource not in self._ENDPOINTS:
            raise ValueError(f"Unknown resource {resource}")

        resp = self.get(f"{self._ENDPOINTS[resource]}{'/detail' if detail else ''}", **params)
        return resp['data'] if 'data' in resp else resp

    def create_resource(self, resource, **params):
        if resource not in self._ENDPOINTS:
            raise ValueError(f"Unknown resource {resource}")

        resp = self.post(self._ENDPOINTS[resource], **params)
        return resp['data'] if 'data' in resp else resp

    def delete_resource(self, resource, ident):
        if resource not in self._ENDPOINTS:
            raise ValueError(f"Unknown resource {resource}")

        resp = self.delete(f"{self._ENDPOINTS[resource]}/{ident}")
        return resp['data'] if 'data' in resp else resp

    def update_resource(self, resource, ident, **params):
        if resource not in self._ENDPOINTS:
            raise ValueError(f"Unknown resource {resource}")

        resp = self.put(f"{self._ENDPOINTS[resource]}/{ident}", **params)
        return resp['data'] if 'data' in resp else resp

    def perform_resource_action(self, resource, ident, action, **params):
        if resource not in self._ENDPOINTS:
            raise ValueError(f"Unknown resource {resource}")

        resp = self.post(f"{self._ENDPOINTS[resource]}/{ident}/actions/{action}", **params)
        return resp['data'] if 'data' in resp else resp

    def perform_bulk_resource_action(self, resource, action, **params):
        if resource not in self._ENDPOINTS:
            raise ValueError(f"Unknown resource {resource}")

        resp = self.post(f"{self._ENDPOINTS[resource]}/actions/{action}", **params)
        return resp['data'] if 'data' in resp else resp
