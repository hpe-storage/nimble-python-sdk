#
#   Â© Copyright 2020 Hewlett Packard Enterprise Development LP
#

import logging
import uuid
import requests
import json

# from requests.packages.urllib3.exceptions import InsecureRequestWarning
from ..exceptions import NimOSAuthenticationError, NimOSAPIError

requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)


class SessionManager:
    """Tracks current NimOS REST sessions in order to reuse them"""

    _SESSIONS = {}


class NimOSAPIClient:
    """NimOS REST API Client session"""

    _ENDPOINTS = {
        # This endpoint list was auto-generated by the Python SDK generator; DO NOT EDIT.
        'versions': 'versions',
        'application_categories': 'v1/application_categories',
        'chap_users': 'v1/chap_users',
        'master_key': 'v1/master_key',
        'alarms': 'v1/alarms',
        'volumes': 'v1/volumes',
        'shelves': 'v1/shelves',
        'support': 'v1/support',
        'key_managers': 'v1/key_managers',
        'protection_templates': 'v1/protection_templates',
        'folders': 'v1/folders',
        'tokens': 'v1/tokens',
        'fibre_channel_interfaces': 'v1/fibre_channel_interfaces',
        'network_interfaces': 'v1/network_interfaces',
        'arrays': 'v1/arrays',
        'fibre_channel_configs': 'v1/fibre_channel_configs',
        'initiators': 'v1/initiators',
        'performance_policies': 'v1/performance_policies',
        'space_domains': 'v1/space_domains',
        'snapshot_collections': 'v1/snapshot_collections',
        'replication_partners': 'v1/replication_partners',
        'events': 'v1/events',
        'snapshots': 'v1/snapshots',
        'application_servers': 'v1/application_servers',
        'user_policies': 'v1/user_policies',
        'user_groups': 'v1/user_groups',
        'subnets': 'v1/subnets',
        'controllers': 'v1/controllers',
        'fibre_channel_sessions': 'v1/fibre_channel_sessions',
        'users': 'v1/users',
        'protection_schedules': 'v1/protection_schedules',
        'initiator_groups': 'v1/initiator_groups',
        'access_control_records': 'v1/access_control_records',
        'active_directory_memberships': 'v1/active_directory_memberships',
        'fibre_channel_ports': 'v1/fibre_channel_ports',
        'protocol_endpoints': 'v1/protocol_endpoints',
        'witnesses': 'v1/witnesses',
        'jobs': 'v1/jobs',
        'audit_log': 'v1/audit_log',
        'pools': 'v1/pools',
        'volume_collections': 'v1/volume_collections',
        'disks': 'v1/disks',
        'fibre_channel_initiator_aliases': 'v1/fibre_channel_initiator_aliases',
        'groups': 'v1/groups',
        'software_versions': 'v1/software_versions',
        'network_configs': 'v1/network_configs',
    }

    def __init__(self, hostname, username, password, port=5392):
        """Initialize a session to the NimOS REST API"""

        connection_hash = str(uuid.uuid3(uuid.NAMESPACE_OID, f'{hostname}{port}{username}{password}'))

        self.hostname = hostname
        self.port = port

        self.__auth = {
            'data': {
                'username': username,
                'password': password,
                'app_name': 'NimOS REST Client'
            }
        }

        self.__connection_hash = connection_hash

        if connection_hash in SessionManager._SESSIONS:
            self.session_id, self.session_token = SessionManager._SESSIONS[connection_hash]
            self.connected = True
            self._headers = {'X-Auth-Token': str(self.session_token)}

        else:
            self._headers = {}
            self.session_token = None
            self.session_id = None
            self.connected = self._connect()

    def _connect(self):
        """Perform NimOS authentication and session token retrieval"""

        try:
            response = requests.post(
                f"https://{self.hostname}:{self.port}/{self._ENDPOINTS['tokens']}",
                json=self.__auth,
                verify=False
            )

            sessiondata = response.json()

            if 'messages' in sessiondata and sessiondata['messages'][0]['code'] == 'SM_http_unauthorized':
                logging.debug(sessiondata)
                raise NimOSAuthenticationError("Invalid credentials")

            sessiondata = sessiondata['data']

            if 'session_token' not in sessiondata:
                logging.debug(sessiondata)
                raise NimOSAuthenticationError("Invalid credentials")

            self.session_token = sessiondata['session_token']
            self.session_id = sessiondata['id']
            self._headers = {'X-Auth-Token': str(self.session_token)}

            SessionManager._SESSIONS[self.__connection_hash] = (self.session_id, self.session_token)

            return True

        except requests.ConnectionError as error:
            logging.exception(error)
            raise ConnectionError(f"Error connecting to {self.hostname}")

    def _refresh_connection(self):
        """Checks status of NimOS session and reconnects if necessary"""

        try:
            response = requests.get(
                f"https://{self.hostname}:{self.port}/{self._ENDPOINTS['tokens']}/{self.session_id}",
                headers=self._headers,
                verify=False
            ).json()

            if 'messages' in response and response['messages'][0]['severity'] == 'error':
                self._connect()

        except requests.ConnectionError as error:
            logging.exception(error)
            raise ConnectionError(f"Error reconnecting to {self.hostname}")

    def close_connection(self):
        """Closes NimOS session (deletes user token)"""

        try:
            requests.delete(
                f"https://{self.hostname}:{self.port}/{self._ENDPOINTS['tokens']}/{self.session_id}",
                headers=self._headers,
                verify=False
            )

            del SessionManager._SESSIONS[self.__connection_hash]

        except requests.exceptions.RequestException as error:
            logging.exception(error)
            raise ConnectionError("Error closing connection")

    def get(self, endpoint, **params):
        """Wrapper for GET requests"""

        try:
            return self.get_data(endpoint, **params)

        except requests.exceptions.RequestException as error:
            logging.exception(error)
            raise ConnectionError(f"Error retrieving data from {self.hostname}")

    def get_data(self, endpoint, filter=None, **params):
        """Wrapper for GET requests with filters and advanced criteria"""

        url = f'https://{self.hostname}:{self.port}/{endpoint}'

        logging.debug("Params: %s", json.dumps(params, indent=4))
        try:
            while 1:
                if filter is not None:
                    logging.debug("Advanced Criteria Filter: %s", json.dumps(self.build_advanced_criteria(filter), indent=4))
                    response = requests.post(
                        url,
                        params=params,
                        json=self.build_advanced_criteria(filter),
                        headers=self._headers,
                        verify=False
                    )
                else:
                    response = requests.get(
                        url,
                        params=params,
                        headers=self._headers,
                        verify=False
                    )

                if response.status_code >= 400:
                    if 'SM_http_unauthorized' in str(response.content):
                        self._refresh_connection()
                    else:
                        raise NimOSAPIError(response.json())
                else:
                    break

            # Check for errors if any in the response (Treat partial response as an error)
            if 'messages' in response.json():
                raise NimOSAPIError(response.json()['messages'])

            # Retrieves as per 'rest_api_row_limit' configuration on array
            if 'pageSize' in params:
                return response.json()

            if 'totalRows' not in response.json():
                return response.json()

            # If startRow and/or endRow is specified, then retrieve records accordingly.
            # If unspecified, then retrieves all the available records.
            paginated_data = list()
            paginated_data.extend(response.json()["data"])
            total_rows = response.json()['totalRows']
            retrieved_rows = len(paginated_data)
            # current_end_row = response.json()['endRow']

            if 'startRow' in params and 'endRow' in params:
                requested_rows = params['endRow'] - params['startRow']
            elif 'startRow' not in params and 'endRow' not in params:
                requested_rows = total_rows  # Get all available records
            else:
                if 'startRow' in params:
                    requested_rows = total_rows - params['startRow']
                else:
                    requested_rows = params['endRow']

            logging.debug("Total records requested: %d, Retrieved records: %d", requested_rows, retrieved_rows)

            pending_rows = requested_rows-retrieved_rows
            params.clear()
            while pending_rows > 0:
                params['startRow'] = response.json()['endRow']
                logging.debug("Retrieved: %d, Pending: %d, Next startRow: %d", retrieved_rows, pending_rows, params['startRow'])
                if filter is not None:
                    response = requests.post(
                        url,
                        params=params,
                        json=self.build_advanced_criteria(filter),
                        headers=self._headers,
                        verify=False
                    )
                else:
                    response = requests.get(
                        url,
                        params=params,
                        headers=self._headers,
                        verify=False,
                    )
                records = response.json()["data"][:pending_rows]
                records_count = len(records)
                paginated_data.extend(records)
                pending_rows -= records_count
                retrieved_rows += records_count
                # TODO: Handle change in the total no. of rows during this large operation

            return paginated_data

        except requests.exceptions.RequestException as error:
            logging.exception(error)
            raise ConnectionError(f"Error retrieving data from {self.hostname}")

    def delete(self, endpoint):
        """Wrapper for DELETE requests"""

        try:
            while 1:
                response = requests.delete(
                    f'https://{self.hostname}:{self.port}/{endpoint}',
                    headers=self._headers,
                    verify=False
                )

                if response.status_code >= 400:
                    if 'SM_http_unauthorized' in str(response.content):
                        self._refresh_connection()
                    else:
                        raise NimOSAPIError(response.json())
                else:
                    break

            return response.json()

        except requests.exceptions.RequestException as error:
            logging.exception(error)
            raise ConnectionError(f"Error communicating with {self.hostname}")

    def put(self, endpoint, **payload):
        """Wrapper for PUT requests"""

        # Translate metadata dict to REST key-value pairs.
        # Ex: {'k1': 'k1', 'k2': 'v2'} ==> [{'key': 'k1', 'value': 'v1'}, {'key': 'k2', 'value': 'v2'}]
        if 'metadata' in payload:
            payload['metadata'] = [{'key': key, 'value': payload['metadata'][key]} for key in payload['metadata']]

        try:
            while 1:
                logging.debug("Payload: %s", json.dumps(payload, indent=4))
                response = requests.put(
                    f'https://{self.hostname}:{self.port}/{endpoint}',
                    headers=self._headers,
                    json={'data': payload},
                    verify=False
                )

                if response.status_code >= 400:
                    if 'SM_http_unauthorized' in str(response.content):
                        self._refresh_connection()
                    else:
                        raise NimOSAPIError(response.json())
                else:
                    break

            return response.json()

        except requests.exceptions.RequestException as error:
            logging.exception(error)
            raise ConnectionError(f"Error communicating with {self.hostname}")

    def post(self, endpoint, **params):
        """Wrapper for POST requests"""

        # Translate metadata dict to REST key-value pairs.
        # Ex: {'k1': 'k1', 'k2': 'v2'} ==> [{'key': 'k1', 'value': 'v1'}, {'key': 'k2', 'value': 'v2'}]
        if 'metadata' in params:
            params['metadata'] = [{'key': key, 'value': params['metadata'][key]} for key in params['metadata']]

        try:
            while 1:
                logging.debug("Params: %s", json.dumps(params, indent=4))
                response = requests.post(
                    f'https://{self.hostname}:{self.port}/{endpoint}',
                    headers=self._headers,
                    json={'data': params},
                    verify=False
                )

                if response.status_code >= 400:
                    if 'SM_http_unauthorized' in str(response.content):
                        self._refresh_connection()
                    else:
                        raise NimOSAPIError(response.json())
                else:
                    break

            return response.json()

        except requests.exceptions.RequestException as error:
            logging.exception(error)
            raise ConnectionError(f"Error communicating with {self.hostname}")

    def get_resource(self, resource, ident, **params):
        if resource not in self._ENDPOINTS:
            raise ValueError(f"Unknown resource {resource}")

        resp = self.get(f"{self._ENDPOINTS[resource]}/{ident}", **params)
        return resp['data'] if 'data' in resp else resp

    def list_resources(self, resource, detail=False, filter=None, **params):
        if resource not in self._ENDPOINTS:
            raise ValueError(f"Unknown resource {resource}")

        if filter is not None:
            resp = self.get_data(f"{self._ENDPOINTS[resource]}{'/detail' if detail else ''}", filter, **params)
        else:
            resp = self.get(f"{self._ENDPOINTS[resource]}{'/detail' if detail else ''}", **params)
        return resp['data'] if 'data' in resp else resp

    def create_resource(self, resource, **params):
        if resource not in self._ENDPOINTS:
            raise ValueError(f"Unknown resource {resource}")

        resp = self.post(self._ENDPOINTS[resource], **params)
        return resp['data'] if 'data' in resp else resp

    def delete_resource(self, resource, ident):
        if resource not in self._ENDPOINTS:
            raise ValueError(f"Unknown resource {resource}")

        resp = self.delete(f"{self._ENDPOINTS[resource]}/{ident}")
        return resp['data'] if 'data' in resp else resp

    def update_resource(self, resource, ident, **params):
        if resource not in self._ENDPOINTS:
            raise ValueError(f"Unknown resource {resource}")

        resp = self.put(f"{self._ENDPOINTS[resource]}/{ident}", **params)
        return resp['data'] if 'data' in resp else resp

    def perform_resource_action(self, resource, ident, action, **params):
        if resource not in self._ENDPOINTS:
            raise ValueError(f"Unknown resource {resource}")

        resp = self.post(f"{self._ENDPOINTS[resource]}/{ident}/actions/{action}", **params)
        return resp['data'] if 'data' in resp else resp

    def perform_bulk_resource_action(self, resource, action, **params):
        if resource not in self._ENDPOINTS:
            raise ValueError(f"Unknown resource {resource}")

        resp = self.post(f"{self._ENDPOINTS[resource]}/actions/{action}", **params)
        return resp['data'] if 'data' in resp else resp

    def build_advanced_criteria(self, filter):
        """Construct Advanced Criteria JSON object"""

        data = {}
        data["_constructor"] = "AdvancedCriteria"
        data["operator"] = filter['operator']
        data["criteria"] = filter['criteria']
        advancedCriteria = {
                                "data": data,
                                "operationType": "fetch"
                            }
        return advancedCriteria
